---
title: "QueryGate: 코드 없이 API를 만드는 Config-driven 게이트웨이"
description: "YAML 설정만으로 API를 생성하는 Micronaut 기반 게이트웨이의 설계와 구현을 살펴봅니다."
date: 2026-02-12
category: "project"
tags: ["java", "micronaut", "mybatis", "api-gateway", "virtual-threads", "docker"]
draft: false
---

## 프로젝트 소개

백엔드 개발에서 반복되는 패턴이 있다. 데이터베이스 테이블이 하나 추가될 때마다 Controller, Service, Repository, DTO 클래스를 작성하고, 빌드하고, 배포하는 과정이다. 테이블 구조가 바뀌면 다시 코드를 수정하고 전체 사이클을 반복해야 한다.

[QueryGate](https://github.com/Clickin/querygate)는 이 반복을 제거하기 위해 만든 config-driven API gateway이다. Java 코드를 한 줄도 작성하지 않고, YAML 설정 파일과 MyBatis XML mapper만으로 REST API endpoint를 생성할 수 있다. Micronaut 4.6.1 위에 구축했고, Java 25의 virtual threads를 활용해 높은 동시성을 확보했다.

핵심 아이디어는 단순하다.

1. YAML 파일에 HTTP method, path, SQL mapping을 선언한다
2. MyBatis XML mapper에 실제 SQL을 작성한다
3. 서버가 시작되면 YAML을 읽어 동적으로 라우팅 테이블을 구성한다
4. 설정 파일이 변경되면 서버 재시작 없이 hot reload한다

프로젝트 구조는 다음과 같다.

```
querygate/
├── config/
│   ├── endpoint-config.yml    # API endpoint 정의
│   └── mappers/               # MyBatis XML mapper 파일
├── src/main/java/querygate/
│   ├── controller/            # 동적 라우팅 컨트롤러
│   ├── service/               # SQL 실행, 입력 병합, 응답 직렬화
│   ├── config/                # 설정 로더, MyBatis 팩토리, Virtual Thread
│   ├── validation/            # 파라미터 검증
│   ├── security/              # API Key 인증
│   └── exception/             # 에러 핸들링
└── build.gradle
```

---

## 동적 라우팅: YAML 설정만으로 API 생성

QueryGate의 핵심은 `endpoint-config.yml` 파일이다. 이 파일 하나로 전체 API surface를 정의한다.

```yaml
# yaml-language-server: $schema=https://raw.githubusercontent.com/Clickin/querygate/main/src/main/resources/schemas/endpoint-config.schema.json
version: "1.0"

defaults:
  response-format: WRAPPED
  max-rows: 1000
  timeout-seconds: 30

endpoints:
  - path: /api/users
    method: GET
    sql-id: UserMapper.selectAllUsers
    sql-type: SELECT
    description: "Retrieve all users with optional filters"
    validation:
      required: []
      optional:
        - name: status
          type: string
          allowed-values: [ACTIVE, INACTIVE, PENDING]
        - name: limit
          type: integer
          min: 1
          max: 100
          default: 20

  - path: /api/users/{id}
    method: GET
    sql-id: UserMapper.selectUserById
    sql-type: SELECT
    validation:
      required:
        - name: id
          type: long
          source: path
```

`EndpointConfigLoader`가 이 YAML을 파싱해서 두 종류의 라우팅 테이블을 구축한다. 정확한 경로 매칭을 위한 `ConcurrentHashMap`과, path variable이 포함된 패턴 매칭을 위한 `CopyOnWriteArrayList`이다.

```java
// 정확한 경로: ConcurrentHashMap으로 O(1) 조회
private final Map<EndpointKey, EndpointConfig> endpointMap = new ConcurrentHashMap<>();

// 패턴 경로: CopyOnWriteArrayList로 thread-safe 순회
private final List<PatternEndpoint> patternEndpoints = new CopyOnWriteArrayList<>();
```

`/api/users/{id}` 같은 패턴 경로는 정규식으로 컴파일된다.

```java
private Pattern compilePathPattern(String path) {
    String regex = PATH_VARIABLE_PATTERN.matcher(path).replaceAll("([^/]+)");
    regex = regex.replace(".", "\\.");
    return Pattern.compile("^" + regex + "$");
}
```

요청이 들어오면 `DynamicRoutingController`가 exact match를 먼저 시도하고, 실패하면 pattern match로 fallback한다. 이 전략 덕분에 대부분의 요청은 HashMap lookup으로 O(1)에 처리된다.

```java
public EndpointConfig findMatchingEndpoint(String method, String requestPath) {
    String upperMethod = method.toUpperCase();

    // exact match 우선
    EndpointConfig exact = endpointMap.get(new EndpointKey(upperMethod, requestPath));
    if (exact != null) {
        return exact;
    }

    // pattern match fallback
    for (PatternEndpoint pe : patternEndpoints) {
        if (pe.method().equals(upperMethod) && pe.pattern().matcher(requestPath).matches()) {
            return pe.config();
        }
    }
    return null;
}
```

YAML 파일은 시작 시 JSON Schema로 검증된다. `endpoint-config.schema.json`을 `src/main/resources/schemas/`에 포함해서, IDE에서 YAML 작성 시 자동 완성과 실시간 검증을 제공한다.

---

## MyBatis 통합과 외부 XML 매퍼

QueryGate는 MyBatis Starter를 사용하지 않는다. `MyBatisFactory`에서 직접 `SqlSessionFactory`를 구성하고, 외부 디렉토리(`config/mappers/`)에서 XML mapper를 로드한다. 이렇게 한 이유는 mapper 파일을 JAR 외부에 두어 hot reload를 가능하게 하기 위해서다.

```java
@Singleton
@Context
public SqlSessionFactory sqlSessionFactory() {
    SqlSessionFactory factory = createSqlSessionFactory();
    sessionFactoryRef.set(factory);
    return factory;
}
```

`AtomicReference<SqlSessionFactory>`를 사용해서 hot reload 시 기존 factory를 새 factory로 원자적으로 교체한다.

```java
public SqlSessionFactory reload() {
    SqlSessionFactory newFactory = createSqlSessionFactory();
    SqlSessionFactory oldFactory = sessionFactoryRef.getAndSet(newFactory);
    return newFactory;
}
```

외부 mapper 로딩은 `XMLMapperBuilder`를 직접 사용한다.

```java
private void loadMapper(Configuration configuration, Path mapperFile) {
    try (InputStream is = Files.newInputStream(mapperFile)) {
        XMLMapperBuilder mapperBuilder = new XMLMapperBuilder(
                is, configuration, resourcePath, configuration.getSqlFragments());
        mapperBuilder.parse();
    }
}
```

SQL 실행은 `DynamicSqlService`가 담당한다. `switch` expression으로 SQL type별 실행 메서드를 분기하고, Micrometer `Timer`로 실행 시간을 측정한다.

```java
SqlExecutionResult result = switch (endpointConfig.sqlType()) {
    case SELECT -> executeSelect(endpointConfig.sqlId(), parameters);
    case INSERT -> executeInsert(endpointConfig.sqlId(), parameters);
    case UPDATE -> executeUpdate(endpointConfig.sqlId(), parameters);
    case DELETE -> executeDelete(endpointConfig.sqlId(), parameters);
    case BATCH  -> executeBatch(endpointConfig, parameters);
};
```

BATCH 연산은 `ExecutorType.BATCH` 세션을 열고, 설정된 `batchSize` 단위로 flush와 commit을 반복한다. 실패 시 rollback이 보장된다.

---

## Hot Reload 구현

QueryGate의 차별점은 설정 변경 시 서버를 재시작할 필요가 없다는 것이다. `XmlReloadService`가 Java `WatchService`로 파일 시스템을 감시하고, 변경이 감지되면 자동으로 reload한다.

```java
@Singleton
@Context
@Requires(property = "gateway.hot-reload.enabled", value = "true", defaultValue = "true")
public class XmlReloadService {

    public void startWatching() {
        if (running.compareAndSet(false, true)) {
            watchService = FileSystems.getDefault().newWatchService();
            registerWatchPaths();

            // virtual thread로 watcher 실행
            watchThread = Thread.ofVirtual()
                    .name("xml-reload-watcher")
                    .start(this::watchLoop);
        }
    }
}
```

두 가지를 감시한다.

1. `config/mappers/*.xml` -- mapper 파일이 변경되면 `MyBatisFactory.reload()`로 `SqlSessionFactory`를 재생성
2. `config/endpoint-config.yml` -- endpoint 설정이 변경되면 `EndpointConfigLoader.reloadConfiguration()`으로 라우팅 테이블 재구축

빠른 연속 변경에 대한 debounce도 구현되어 있다. `WatchKey`를 poll한 후 100ms 대기하여 여러 이벤트를 하나의 reload로 합친다.

```java
WatchKey key = watchService.poll(
        properties.hotReload().pollIntervalMs(),
        TimeUnit.MILLISECONDS);

if (key == null) continue;

// debounce
Thread.sleep(100);
```

이 watcher 자체도 virtual thread로 실행되므로 platform thread를 소비하지 않는다.

---

## Java 25 Virtual Threads 활용

QueryGate는 Java 25의 virtual threads를 적극 활용한다. `VirtualThreadExecutorFactory`에서 `Executors.newThreadPerTaskExecutor()`로 virtual thread executor를 생성하고, 이를 Micronaut의 `@ExecuteOn` 어노테이션과 연결한다.

```java
@Singleton
@Named("gatewayVirtualExecutor")
@Requires(property = "gateway.virtual-threads.enabled", value = "true", defaultValue = "true")
public ExecutorService virtualThreadExecutor(GatewayProperties properties) {
    return Executors.newThreadPerTaskExecutor(
            Thread.ofVirtual()
                    .name(executorName, 0)
                    .factory()
    );
}
```

Controller에서는 `@ExecuteOn("gatewayVirtualExecutor")`로 모든 요청을 virtual thread에서 처리한다.

```java
@Controller("/api")
@Secured(SecurityRule.IS_AUTHENTICATED)
@ExecuteOn("gatewayVirtualExecutor")
public class DynamicRoutingController {
    // ...
}
```

이 설계의 이점은 database I/O 대기 시간에 platform thread가 차단되지 않는다는 것이다. 각 요청이 자체 virtual thread에서 실행되므로 수천 개의 동시 요청을 platform thread pool 크기에 관계없이 처리할 수 있다. HikariCP connection pool(기본 20)이 실질적인 동시성 병목이 된다.

Virtual threads가 비활성화된 환경을 위한 fallback도 준비되어 있다. `@Requires` 조건부 빈으로, `gateway.virtual-threads.enabled=false`일 때는 bounded platform thread pool을 생성한다. `CallerRunsPolicy`로 backpressure를 적용해서 과부하를 방지한다.

---

## RAW/WRAPPED 응답 포맷

QueryGate는 두 가지 응답 포맷을 지원한다.

**WRAPPED** (기본값)는 metadata를 포함한 envelope 형식이다.

```json
{
  "success": true,
  "data": [{"id": 1, "username": "user1"}],
  "count": 1,
  "sqlType": "SELECT"
}
```

**RAW**는 데이터를 직접 반환한다.

```json
[{"id": 1, "username": "user1"}]
```

RAW 포맷에서 문제가 되는 것은 에러 처리다. 클라이언트가 `List<User>`를 기대하는데 `{"success": false, "error": "..."}`가 반환되면 DTO mapping이 실패한다. QueryGate는 이 문제를 HTTP header 기반 에러 응답으로 해결했다.

RAW 포맷 endpoint에서 에러가 발생하면 body를 비우고, 에러 정보를 custom header로 전달한다.

```
HTTP/1.1 400 Bad Request
X-Error-Type: ValidationError
X-Error-Message: Request validation failed
Content-Length: 0
```

클라이언트는 HTTP status code를 먼저 확인하고, 에러인 경우 header에서 상세 정보를 읽는다.

```typescript
const response = await fetch('/api/users');
if (!response.ok) {
  const errorType = response.headers.get('X-Error-Type');
  const errorMessage = response.headers.get('X-Error-Message');
  throw new Error(`${errorType}: ${errorMessage}`);
}
const users: User[] = await response.json(); // 안전한 DTO mapping
```

에러 정보의 노출 수준은 `application.yml`로 제어한다.

```yaml
gateway:
  error-handling:
    expose-details: false    # production에서는 false
    expose-stack-trace: false
```

`expose-details: false`이면 SQL ID, query 구조, MyBatis mapper 이름 같은 내부 정보가 숨겨진다. Header injection 방지를 위해 header 값에서 control character도 제거한다.

---

## Docker Quick Start와 JSON Schema IDE 지원

QueryGate는 5분 안에 시작할 수 있는 Docker 환경을 제공한다.

```dockerfile
FROM eclipse-temurin:25-jdk AS builder
WORKDIR /build
COPY gradlew gradle build.gradle settings.gradle gradle.properties ./
COPY src src
RUN ./gradlew build -x test --no-daemon

FROM eclipse-temurin:25-jre-alpine
RUN addgroup -g 1000 querygate && \
    adduser -u 1000 -G querygate -s /bin/sh -D querygate
WORKDIR /app
COPY --from=builder /build/build/libs/*.jar app.jar
USER querygate
EXPOSE 8080
HEALTHCHECK --interval=30s --timeout=5s --start-period=30s --retries=3 \
  CMD curl -f http://localhost:8080/health || exit 1
ENV JAVA_OPTS="-XX:+UseContainerSupport -XX:MaxRAMPercentage=75.0 \
               -XX:+UseG1GC -XX:+UseStringDeduplication"
ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
```

Multi-stage build로 이미지 크기를 최소화하고, non-root user로 실행하며, `HEALTHCHECK`로 컨테이너 상태를 모니터링한다. `MaxRAMPercentage=75.0`으로 컨테이너 메모리 한도의 75%를 JVM에 할당한다.

`docker-compose.yml`은 H2 in-memory database와 함께 즉시 실행 가능한 환경을 구성한다.

```yaml
services:
  querygate:
    build: .
    ports:
      - "8080:8080"
    environment:
      - JDBC_URL=jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1
      - GATEWAY_SECURITY_ENABLED=false
      - MICRONAUT_SERVER_VIRTUAL_THREADS_ENABLED=true
    volumes:
      - ./config:/app/config:ro
```

```bash
docker-compose up -d
curl http://localhost:8080/health
```

개발 경험도 중요하게 다뤘다. YAML 파일 상단에 JSON Schema 참조를 추가하면 IDE에서 자동 완성과 실시간 검증을 받을 수 있다.

```yaml
# yaml-language-server: $schema=https://raw.githubusercontent.com/Clickin/querygate/main/src/main/resources/schemas/endpoint-config.schema.json
```

VS Code의 YAML extension이나 JetBrains IDE에서 바로 동작한다. endpoint의 `method`, `sql-type`, `response-format` 같은 enum 값을 자동 완성해주고, 필수 필드 누락을 즉시 경고한다.

build.gradle에서는 external JDBC driver 관리도 눈에 띈다. Oracle, MySQL, PostgreSQL, SQL Server 드라이버를 별도 `externalDrivers` configuration으로 분리해서, 기본 JAR에는 포함하지 않고 `lib/` 폴더에 배포한다.

```groovy
configurations {
    externalDrivers
}

dependencies {
    // H2는 기본 포함
    runtimeOnly("com.h2database:h2")

    // 외부 드라이버는 별도 관리
    externalDrivers("com.oracle.database.jdbc:ojdbc11:23.3.0.23.09")
    externalDrivers("com.mysql:mysql-connector-j:8.3.0")
    externalDrivers("org.postgresql:postgresql:42.7.2")
    externalDrivers("com.microsoft.sqlserver:mssql-jdbc:12.6.1.jre11")
}
```

이 접근법으로 기본 JAR 크기를 줄이면서, 배포 환경에 맞는 드라이버만 `lib/` 폴더에 넣어 사용할 수 있다.

---

## Claude Code를 활용한 코드 리뷰 자동화

QueryGate 개발 과정에서 흥미로운 실험을 했다. Claude Code로 코드 리뷰를 수행하고, 발견된 이슈를 PR로 만들어 바로 병합하는 자동화 워크플로우다. PR #2, #3, #4가 이 실험의 결과물이다.

**PR #2** ("Analyze QueryGate API gateway architecture")는 초기 아키텍처 분석에서 나온 첫 수정이다. thread safety 문제 두 가지를 발견하고 수정했다.

- `SimpleDateFormat`을 `DateTimeFormatter`로 교체: `SimpleDateFormat`은 thread-safe하지 않아서, virtual thread 환경에서 concurrent access 시 날짜 포맷이 깨질 수 있었다.
- `patternEndpoints`를 `CopyOnWriteArrayList`로 변경: hot reload 시 라우팅 리스트를 순회하는 중에 수정이 발생하면 `ConcurrentModificationException`이 발생할 수 있었다.

**PR #3** ("Unify ObjectMapper usage to Micronaut Serde and improve thread safety")는 테스트 코드의 일관성 문제를 해결했다. Production 코드는 Micronaut Serde의 `ObjectMapper`를 사용하는데, 테스트 코드에서는 Jackson의 `ObjectMapper`를 직접 사용하고 있었다. Serde의 직렬화 동작이 Jackson과 다를 수 있으므로, 테스트도 `@MicronautTest`로 주입받는 방식으로 통일했다.

**PR #4** ("Apply QueryGate technical review recommendations")가 가장 대규모 변경이다. 1,055줄 추가, 15개 파일 수정, 네 번의 커밋으로 구성되어 있다.

1. **Error handling 강화 (P0)**: `RequestBodyParseException`을 추가해서 JSON/XML 파싱 실패 시 HTTP 400을 명확히 반환하도록 했다. 기존에는 파싱 실패가 조용히 처리되어 디버깅이 어려웠다.

2. **JSON Schema 도입 (P0)**: `endpoint-config.schema.json`을 작성해서 IDE 자동 완성을 지원했다. 처음에는 `config/` 디렉토리에 넣었다가, config 폴더는 런타임 설정 전용이라는 판단으로 `src/main/resources/schemas/`로 이동했다.

3. **Health indicator 추가 (P1)**: `DatabaseHealthIndicator`와 `ConfigurationHealthIndicator`를 구현해서 `/health` endpoint에서 DB 연결 상태와 endpoint 설정 유효성을 확인할 수 있게 했다.

4. **RAW 포맷 에러 처리 (P0)**: 앞서 설명한 header 기반 에러 응답을 구현했다. 이것은 실제 운영 환경에서 typed HTTP client를 사용할 때 발생하는 문제를 예방하는 설계다.

세 PR 모두 Claude Code가 커밋 author이고, 하루(2025-12-04) 안에 리뷰부터 병합까지 완료되었다. AI 코드 리뷰가 실용적이라는 것을 확인한 사례다. 특히 thread safety 같은 concurrency 버그는 사람이 놓치기 쉬운 영역인데, virtual thread 환경의 특성을 고려한 정확한 지적이 인상적이었다.

---

## 정리

QueryGate는 "코드를 작성하지 않고 API를 만든다"는 단순한 아이디어에서 출발했지만, 실제 운영 환경을 고려하면 hot reload, thread safety, 에러 처리, container 지원 등 상당한 엔지니어링이 필요했다.

설계에서 중요하게 생각한 원칙들을 요약하면 다음과 같다.

- **Configuration as Code**: endpoint 정의를 코드가 아닌 YAML로 관리해서 빌드-배포 사이클 없이 API를 변경할 수 있다
- **Schema validation**: JSON Schema로 설정 파일의 정확성을 보장하고 IDE 지원을 제공한다
- **Thread safety first**: Virtual thread 환경에서의 concurrent access를 고려한 자료구조 선택(`ConcurrentHashMap`, `CopyOnWriteArrayList`, `AtomicReference`)
- **Fail safe**: hot reload 실패 시 기존 설정을 유지하고, 에러 정보 노출을 production 환경에 맞게 제어한다
- **Zero overhead start**: Docker Compose 한 줄로 H2 기반 데모 환경을 시작할 수 있다

소스 코드는 [GitHub](https://github.com/Clickin/querygate)에서 확인할 수 있다.
