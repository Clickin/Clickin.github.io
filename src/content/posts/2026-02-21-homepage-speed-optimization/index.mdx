---
title: "블로그 속도 향상 과정 정리"
description: "렌더 블로킹 리소스, 폰트, 서드파티 스크립트를 중심으로 블로그 체감 속도를 개선한 과정을 정리합니다."
date: 2026-02-21
category: "dev"
tags: ["performance", "astro", "lighthouse", "web-vitals", "optimization"]
draft: true
publish: false
---

## 서론

블로그를 본격적으로 가동하기 전에 점검하다보니 기능 자체는 문제가 없지만 체감 렌더링 속도가 둔하게 느껴지는 구간이 있었습니다.
특히 첫 화면 렌더링 경로에서 불필요하게 앞당겨 로드되는 리소스가 있었고, 이 부분을 줄이면 같은 인프라에서도 충분히 빨라질 수 있다고 판단했습니다.
최종적으로 github page 시스템 안에서 사용 가능한 최적화를 적용해서 만족할만한 성능을 얻었습니다.

이번 작업의 목표는 단순했습니다.

1. **초기 렌더링 경로를 가볍게 만들기**
2. **필수 리소스만 먼저 가져오게 만들기**
3. **측정 가능한 형태로 개선 근거를 남기기**

---

## 개선 포인트를 선정한 과정 (Lighthouse 진단 절차)

결론부터 구현한 게 아니라, Chrome DevTools의 Lighthouse(Mobile)로 먼저 병목을 확인한 뒤 우선순위를 정했습니다.
이번 글에서는 숫자 추출 과정보다, 실제 리포트 화면을 기준으로 어떻게 판단했는지에 집중합니다.

### 1) Baseline 측정 고정

- 동일한 조건(Mobile 프로파일)에서 **이전 버전/현재 버전**을 각각 측정
- 두 리포트에서 동일 지표(FCP, LCP, Speed Index, TBT, CLS)를 같은 위치에서 비교
- 점수 하나만 보지 않고, 하단 Insight 항목까지 함께 확인

아래 두 캡처를 나란히 두고 비교하면 개선 포인트가 가장 빠르게 보입니다.

- 삽입 예정 이미지 1: `lighthouse-before-mobile.png`
- 삽입 예정 이미지 2: `lighthouse-after-mobile.png`

이미지 파일을 이 글 폴더(`src/content/posts/2026-02-21-homepage-speed-optimization/`)에 넣은 뒤,
아래처럼 본문에 추가하면 됩니다.

```mdx
![Lighthouse before (mobile)](./lighthouse-before-mobile.png)
![Lighthouse after (mobile)](./lighthouse-after-mobile.png)
```

### 2) 병목 후보 식별 (before 리포트)

`before` 캡처에서 바로 보였던 신호는 아래 두 가지였습니다.

- `render-blocking-insight` 점수: `0.5`
  - block 리소스: `https://clickin.github.io/_astro/_slug_.FL87gRx2.css`
  - `totalBytes: 20172`, `wastedMs: 300`
- `cache-insight` 점수: `0.5` (`Est savings of 18 KiB`)
  - 동일 CSS에서 `cacheLifetimeMs: 600000`, `wastedBytes: 18491`

즉, "초기 렌더 경로에서 CSS 전달 방식이 병목"이라는 가설을 세울 근거가 충분했습니다.

### 3) 병목 -> 액션 매핑

진단 결과를 다음과 같이 바로 액션으로 연결했습니다.

1. `render-blocking-insight` -> CSS 전달 방식 튜닝 (`inlineStylesheets` 유지 + `assetsInlineLimit` 조정)
2. 초기 렌더 경로 부담 완화 -> 비핵심 스크립트(Giscus/Pagefind) 지연 로딩
3. 회귀 방지 -> baseline 측정 스크립트화(`scripts/perf/lighthouse-baseline.mjs`)

### 4) 재측정으로 가설 검증 (after 리포트)

- `render-blocking-insight`: `0.5 -> 1`
- `cache-insight`: `0.5 -> 1`
- FCP/LCP/Speed Index: 각각 `1853.152ms -> 959.558ms` (각 `-48.22%`)

결국 "진단 -> 가설 -> 조치 -> 재측정" 순서로 진행했기 때문에, 개선 결과의 신빙성을 확보할 수 있었습니다.

> 위 수치는 리포트 캡처의 동일 위치에서 읽은 값을 기준으로 정리했습니다.

---

## 이번에 집중한 개선 포인트

### 1) CSS 전달 방식 최적화

Astro의 `build.inlineStylesheets: "auto"`는 유지하되, 실제 번들 크기에 맞게 인라인 기준을 조정했습니다.
핵심은 설정을 극단으로 바꾸는 게 아니라, 현재 사이트의 CSS 크기와 렌더링 병목을 기준으로 threshold를 튜닝한 것입니다.

```js
// astro.config.mjs
build: {
  inlineStylesheets: "auto",
},
vite: {
  build: {
    assetsInlineLimit: 30720,
  },
}
```

이 방식의 장점은 다음과 같습니다.

- 무조건 인라인(`always`)로 가지 않아서 유지보수 리스크를 줄임
- 현재 병목이던 초기 스타일 전달 경로만 집중적으로 완화
- 기존 빌드/배포 흐름을 깨지 않고 적용 가능

### 2) 폰트 로딩 경로 정리

첫 화면에서 폰트가 렌더링 타이밍과 레이아웃 안정성에 미치는 영향이 꽤 컸습니다.
그래서 폰트 전달 경로를 점검하고, 가능한 범위에서 외부 의존성과 초기 레이아웃 흔들림(CLS)을 줄이는 방향으로 정리했습니다.

핵심은 아래 두 가지였습니다.

- 필요한 폰트만 우선적으로 전달
- 폴백 전략을 명확히 해서 폰트 교체 시 점프를 최소화

### 3) 비핵심 스크립트 지연 로딩

댓글(Giscus), 검색(Pagefind)처럼 **초기 렌더링에 필수가 아닌 기능**은 사용자 의도 시점으로 로드를 미뤘습니다.
예를 들어 댓글은 뷰포트 근접/상호작용 시점에 로드되도록 구성해, 첫 화면 JS 경로를 가볍게 유지했습니다.

이 과정에서 특히 신경 쓴 부분은 다음입니다.

- 중복 초기화 방지(idempotency)
- 실패 시 재시도 UX 제공
- 테마 동기화 같은 기존 동작 보존

### 4) 재현 가능한 성능 측정 파이프라인

체감 개선만으로 끝내지 않기 위해, Lighthouse 측정을 스크립트화해 반복 실행 가능한 형태로 만들었습니다.
홈/블로그/검색 경로를 기준으로 baseline을 남기고, 이후 변경의 영향을 같은 조건에서 비교할 수 있게 했습니다.

즉, 이번 최적화는 "한 번 빨라진 느낌"이 아니라,
**앞으로도 성능 회귀를 추적할 수 있는 기반을 만드는 작업**까지 포함합니다.

---

## Lighthouse 실측 비교 (Mobile)

아래 표는 Lighthouse before/after 캡처에서 같은 카드 위치의 값을 나란히 정리한 것입니다.

| 지표 | Before | After | 변화량 | 비고 |
|---|---:|---:|---:|---|
| Performance Score | 98 | 100 | +2 | 개선 |
| FCP | 1853.152 ms | 959.558 ms | -893.594 ms (-48.22%) | 개선 |
| LCP | 1853.152 ms | 959.558 ms | -893.594 ms (-48.22%) | 개선 |
| Speed Index | 1853.152 ms | 959.558 ms | -893.594 ms (-48.22%) | 개선 |
| TBT | 0 ms | 77 ms | +77 ms | GA 스크립트 로드 영향 포함 |
| CLS | 0.0016297868335406703 | 0.0016297868335406703 | 0 | 동일 |
| Request Count | 5 | 6 | +1 | GA 요청 추가(의도) |
| Total Byte Weight | 95,746 B | 251,451 B | +155,705 B | 증가분 대부분 GA(의도) |

추가로 Lighthouse insight 항목도 비교했습니다.

- `render-blocking-insight`: **0.5 -> 1**
- `cache-insight`: **0.5 -> 1** (`before`의 displayValue: `Est savings of 18 KiB`)

이번 측정에서는 핵심 렌더링 지표(FCP/LCP/Speed Index)가 크게 개선되었고, CLS는 동일 수준을 유지했습니다.
반면 TBT/요청 수/전송 바이트 증가는 GA 도입으로 인한 의도된 트레이드오프이며, 회귀 여부는 추후 측정으로 지속 확인할 계획입니다.

> 참고: `Request Count`와 `Total Byte Weight` 증가는 최적화 실패로 인한 회귀가 아니라, GA(`googletagmanager.com`, `google-analytics.com`) 요청이 추가되면서 발생한 **의도된 증가분**입니다. 실제 JSON의 네트워크 요청 항목에서도 증가분 대부분이 GA 스크립트/수집 요청으로 확인됩니다.

---

## 작업하면서 얻은 교훈

1. **속도 개선은 큰 개편보다 경로 최적화가 먼저다**  
   인프라를 바꾸지 않아도, 렌더링 임계 경로만 정리해도 체감 차이가 크다.

2. **서드파티는 기능보다 타이밍이 중요하다**  
   같은 스크립트라도 "언제" 로드하느냐가 성능을 크게 좌우한다.

3. **측정 자동화가 있어야 개선이 누적된다**  
   수치 없이 진행하면 결국 감에 의존하게 된다.

---

## 다음 단계(예정)

- 홈/포스트/검색 경로별로 개선 전후 수치(FCP, LCP, CLS, TBT)를 표로 정리
- 모바일 네트워크 조건에서 재측정해 체감 차이 검증
- 성능 개선 항목을 CI 체크리스트에 포함해 회귀 방지

이 글은 우선 Draft로 남겨두고, 수치 테이블과 스크린샷을 보강한 뒤 공개할 예정입니다.
